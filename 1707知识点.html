<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1851"/>

<div>
<span><div>001、什么是一个javascript？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>a、早期是为了验证表单输入的正确性</div><div><br/></div><div>b、现在可以实现页面的交互效果</div><div><br/></div><div>c、跨平台的脚本语言</div><div><br/></div><div>d、网景公司开发出来的  作者布兰登艾奇</div></div><div><br/></div><div>002、cpu   硬盘   内存</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>cpu:中央处理器====》大脑</div><div><br/></div><div>硬盘======》外部存储器    速度慢  内存大  价格略低   永久存储文件</div><div><br/></div><div>内存======》内部存储器    速度快  内存小  价格高     内存时间短</div><div><br/></div><div>内存：ROM  RAM</div><div><br/></div><div>内存：常量池   栈   堆</div></div><div><br/></div><div>003、 <span style="color: rgb(0, 0, 0); font-family: monospace; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;">javascript三大部分组成</span></div><div><span style="font-family: monospace;"><br/></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、ECMAscript====》它是一种规范 造一架汽车------》发动机</div><div><br/></div><div>2、BOM ：browser Object Model===》浏览器</div><div><br/></div><div>3、DOM : document===&gt;页面</div></div><div><span style="font-family: monospace;"><br/></span></div><div>004、变量的规范</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、等号两边要加空格</div><div><br/></div><div>2、不能够使用关键字和保留字</div><div><br/></div><div>3、每一个程序的结尾处一定要加上分号 注意小写 英文状态下的</div></div><div><br/></div><div>005、js中的数据类型有哪些？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>基本数据类型：number string undefined null boolean</div><div><br/></div><div>引用数据类型：object function new Array</div></div><div><br/></div><div>006、undefined 和null的区别?<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">先记住看不懂的会讲的</span></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>null是一个表示&quot;无&quot;的对象，转为数值时为0；undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN。</div><div><br/></div><div>undefined：</div><div>（1）变量被声明了，但没有赋值时，就等于undefined。</div><div>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</div><div>（3）对象没有赋值的属性，该属性的值为undefined。</div><div>（4）函数没有返回值时，默认返回undefined。</div><div><br/></div><div>null：</div><div>（1） 作为函数的参数，表示该函数的参数不是对象。</div><div>（2） 作为对象原型链的终点。</div></div><div><br/></div><div>007、列举js中的隐式类型转换和强制类型转换</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>隐式类型转换：== != - * / % *= /= -= %= i++ ++i</div><div><br/></div><div>强制类型转换：Number parseInt():取整 转换 parseFloat()</div></div><div><br/></div><div>008、如何判断是不是NaN?</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Number.isNaN</div><div><br/></div><div>注意：NaN不等于NaN</div></div><div><br/></div><div>009、 javascript转换成false的值有哪些？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>'' 0  false  undefined  null</div></div><div><br/></div><div>010、js中的运算符有哪些？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>算术运算符：</div><div><br/></div><div>赋值运算符：</div><div><br/></div><div>关系运算符：</div><div><br/></div><div>逻辑运算符：</div><div><br/></div><div>自增自减运算符：</div></div><div><br/></div><div>011、js中i++ 和 ++i的区别</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>前者先使用后赋值</div><div><br/></div><div>后者先赋值在使用</div></div><div><br/></div><div><span style="font-size: 16px;">012、谈谈你对NaN的理解</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>a、Not a Number  不是一个数字</div><div><br/></div><div>b、NaN仅仅代表不是数字，自身和自身都不相等（NaN != NaN）</div><div><br/></div><div>c、如何判断NaN:isNaN===&gt;如果是NaN,返回true,否则返回false</div><div><br/></div><div>d、NaN的数据类型是number</div></div><div><br/></div><div>013、if判断需要注意的地方</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、if后面的()不能省略，()后面不要加分号</div><div><br/></div><div>2、if分支中即使一句话也要把{}写上</div><div><br/></div><div>3、if嵌套不要超过三层</div></div><div><br/></div><div>014、 javascript转换成true的值有哪些？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>true 非0的数字   非空的字符串  object  function</div></div><div><br/></div><div>015、关于if的优化</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、把用的最多的代码放在前面，减少判断次数</div><div><br/></div><div>2、如果在js中有很多if判断,而且可能执行的次数分布也比较均匀，那么后面的判断语句每次都要把前面的判断一个一个执行完,这样是不利于优化的。比较好的做法是将一层判断语句变成两层判断语句</div><div><br/></div><div>注：嵌套if语句的时候最好不要超过三层</div></div><div><br/></div><div>016、关于switch的理解</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、工作原理：</div><div style="margin-left:40px;">首先设置表达式n(通常是一个变量)。随后表达式的值会与结构中的每个case值做比较。如果存在的的话，则执行case关联的代码块。结束的时候一定要用break来组织代码自动向下一个case运行</div><div><br/></div><div>2、表达式的结果等于哪个case的常量，则执行其后的语句，执行完break就跳出switch结构，都不满足则执行default的语句</div><div><br/></div><div>3、switch中的判断是恒等而不是相等</div></div><div><br/></div><div>017、if与switch应用的场景？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>if :</div><div>            1、具体的值进行判断</div><div>            2、区间的判断</div><div>            3、对运算的结果是boolean类型表达式进行判断  true   false</div><div><br/></div><div>switch：</div><div>            1、对具体的值进行判断</div><div>            2、值的个数是固定的</div><div><br/></div><div>            对于几个固定的值判断，建议使用switch 语句。因为switch 语句会将具体的答案都加载进内存，效率相对高一点</div><div>            基于代码的可读性：如果条件较少时,if-else容易阅读,而条件较多时switch更容易阅读</div></div><div><br/></div><div>018、while和 do...while的区别</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>和while规则一样，唯一不同的是do{}while会先执行一次(先执行后判断)<br/></div></div><div><br/></div><div>019、while和for的区别</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>for循环是知道了循环次数，while是不知道循环次数</div><div><br/></div><div>for限定了循环次数</div><div><br/></div><div>while是条件循环</div></div><div><br/></div><div>020、break continue 和return的区别</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、break的作用终止整个循环 判断和循环当中</div><div><br/></div><div>2、continue的作用跳出本次循环继续执行下一次循环  在循环中使用</div><div><br/></div><div>3、return只有函数中才有return 如果函数中return将结果返回后那么后面的代码将不再执行</div></div><div><br/></div><div>021、while需要注意的地方</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>在while循环开始后，先判断条件是否满足，如果满足就执行循环内容，执行完毕后回来继续判断条件是否满足，如此无限循环；直到条件不满足的时候，循环结束</div><div><br/></div><div>注意：一定要在循环体内改变循环的条件<br/></div></div><div><br/></div><div>022、for循环注意的地方</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>循环变量： 用于控制循环是否结束的变量(给变量赋初始值,只执行一次)</div><div>循环条件: 判断循环是否继续(每次都会执行)</div><div>改变循环变量：用于改变循环变量(每次都会执行)</div></div><div><br/></div><div>023、定义函数的方法</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、关键字函数</div><div>     function 函数名(){}</div><div><br/></div><div>2、字面量函数</div><div>     var fn = function(){}</div><div>3、构造函数</div><div>     var fn = new Function(参数,函数体)</div></div><div><br/></div><div>024、立即执行函数语法</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、(function fn(){</div><div>         alert(1) </div><div>     })()</div><div><br/></div><div>2、var fn = (function(){</div><div>     alert(1)</div><div>})()</div></div><div><br/></div><div>025、常见的事件有哪些？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>鼠标事件</div><div>单击事件  onclick</div><div>双击事件  dblclick</div><div>鼠标划入  onmouseover</div><div>鼠标划出  onmouseout</div><div>鼠标滚轮（滚动，单击） onmousewheel</div><div>鼠标的移动  onmousemove</div><div><br/></div><div>键盘</div><div>按下某个键不松开  onkeydown</div><div>抬起某个键    onkeyup</div><div>按下并抬起来   onkeypress</div><div><br/></div><div>输入框</div><div>获取焦点  onfocus</div><div>失去焦点  onblur</div><div>改变输入框的内容  onchange</div></div><div><br/></div><div>026、函数的特点和作用</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、代码可重复利用</div><div><br/></div><div>2、便于修改和控制</div><div><br/></div><div>3、控制代码执行的时机</div></div><div><br/></div><div>027、什么是形参和实参</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、在函数定义的时候括号里面写的变量就是形参</div><div><br/></div><div>2、在函数调用的时候传的参数就是实参</div><div><br/></div><div>二者一一相对应</div></div><div><br/></div><div>028、谈谈对return的理解?</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、如果函数没有写return，默认返回undefined</div><div>2、 函数中遇到return就直接返回，后面的代码将不再执行（类比break）</div><div>3、 只有函数中才有return</div><div>4、 只能return一个结果</div><div>5、需要拿到函数的返回值就需要用到return</div></div><div><br/></div><div>029、什么是变量的声明与提升？</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>变量的提升：变量声明和函数的声明会从他们代码出现的外置移动到执行环境的顶部，这个过程叫提升。只有声明操作会被提升，赋值和逻辑操作只会在原地等待</div><div><br/></div><div>js的预编译会把声明看做2部分，一部分是声明操作 var 变量名   和  赋值操作  变量名=值</div></div><div><br/></div><div>030、作用域&amp;&amp;作用域链</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>作用域：起作用的范围</div><div><br/></div><div>作用域链：作用域的集合</div></div><div><br/></div><div>031、全局变量&amp;&amp;局部变量</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>在函数外部的变量叫做全局变量</div><div><br/></div><div>在函数内部的变量叫做局部变量</div></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">032、简述你对js中堆栈的了解</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>js变量存储有栈存储和堆存储，基本数据类型的变量存储在栈中，引用数据类型的变量存储在堆中 引用类型数据的地址也存在栈中</div><div><br/></div><div>当访问基础类型变量时，直接从栈中取值。当访问引用类型变量时，先从栈中读取地址，在根据地址到堆中取出数据</div><div><br/></div><div>当</div></div><div><br/></div><div>033、谈谈你对arguments的理解</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1、函数内部自带的一个对象，形式和数组类似（被Arguments创造出来的）</div><div><br/></div><div>2、存储的是所有的实参（调用功能传入的参数）</div><div><br/></div><div>3、可以使用[]及下标访问arguments中的内容   arguments[0]  访问第一个实参</div><div><br/></div><div>4、可以使用 arguments.length 确定传入实参的个数  （arguments['length']）</div><div><br/></div><div>最常用的用途： 判断传入参数的个数(根据参数个数做不同的事情)</div></div><div><br/></div><div><span style="font-size: 16px;">034、递归与循环的区别</span></div><div><b><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></b></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>递归算法：</div><div><br/></div><div>优点：代码简洁、清晰，并且容易验证正确性。</div><div><br/></div><div>缺点：</div><div>1、它的运行需要较多次数的函数调用，如果调用层数比较深，每次都要创建新的变量，需要增加额外的堆栈处理，会对执行效率有一定影响，占用过多的内存资源。</div><div>2、递归算法解题的运行效率较低。在递归调用的过程中系统为每一层的返回点、局部变量等开辟了栈来储存。递归次数过多容易造成栈溢出等</div><div><br/></div><div>注意：递归就是在过程或函数里调用自身；使用递归策略时要注意的几个条件</div><div>1、必须有一个明确的递归结束条件，称为递归出口。</div><div>2、递归需要有边界条件、递归前进段和递归返回段。</div><div>3、当边界条件不满足时，递归前进。当边界条件满足时，递归返回。</div><div><br/></div><div>循环算法：</div><div><br/></div><div>优点：速度快，结构简单。</div><div><br/></div><div>缺点：并不能解决所有的问题。有的问题适合使用递归而不是循环。如果使用循环并不困难的话，最好使用循环</div></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">035、</span><span style="font-size: 16px;">对象类型的好处在哪？</span></div><div><span style="font-size: 16px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>使得信息的传递更方便快捷</div></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="color: rgb(51, 51, 51);">036、</span>构造函数是干什么用的？</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>构造函数是初始化已创建好的对象中成员变量的</div></div><div><br/></div><div>037、数组的概念及作用</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>概念：一组(一般情况下相同类型)的数据（不一定都是数字）</div><div><br/></div><div>作用：就是一个容器，将多个数据保存起来</div></div><div><br/></div><div>038、创建数组的几种方式</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>三种方式：</div><div>1、var arr = new Array();</div><div>2、var arr = Array</div><div>3、var arr = [];</div></div><div><br/></div><div>039、如果判断一个对象是不是数组</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>数组.instanceof Array</div></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">040、数组常用的一些方法</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>1、push: 在数组最后添加一个或者多个元素，返回添加后数组的长度</div><div><br/></div><div>2、pop: 从数组最后取出一个元素，返回的是数组的最后一个元素（取出的元素）</div><div><br/></div><div>3、unshift: 和push相反，从数组的第一位的前面开始添加</div><div><br/></div><div>4、shift: 和pop相反从数组的第一位开始取，返回取出的值</div><div><br/></div><div>5、sort 排序方法</div><div><br/></div><div>6、reverse 反转</div><div><br/></div><div>上面的6种方式都在原数组进行操作，会改变原本的数组</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">041、如何将数组转换为字符串？如何将字符串转换为数组</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>var str = 数组.join('')</div><div>var arr = 字符串.split('')</div><div><br/></div><div>除此之外还有toString()</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">042、slice与splice的区别</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>slice只能截取一段字符串</div><div><br/></div><div><br/></div><div>splice:可以替换  插入   删除</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">043、简单谈一谈关于值传递与引用传递</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div> 值传递：传递的是基本数据类型的数据（数据不会发生改变）</div><div><br/></div><div> 引用传递：传递的是对象（数组、对象）对象存储在堆空间中，自身可以发生改变</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">044、关于数组的排序请用至少2种方式进行排序</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><br/></div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">045、什么是json?</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式,用来来存储和表示数据</div><div><br/></div><div>语法：</div><div>     [</div><div>     {键:值},</div><div>     {键:值},</div><div>     {键:值},<br/></div><div>     ]</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">046、什么是ES5?js中的'use strict'是什么？目的是什么？</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>ECMA Script5：ECMA的第五次改版  时间：2009年</div><div><br/></div><div>'use strict'js的严格模式 </div><div><br/></div><div>目的：</div><div>增加更多报错的场合，消除代码运⾏的⼀些不安全之处，保证代码 运行的安全。</div><div>提高编译器效率，增加运⾏速度。</div><div>为未来新版本的JavaScript做好铺垫</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">047、ES5中新增的数组的方法有哪些？</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>indexOf()：返回第一次出现的下标</div><div><br/></div><div>lastIndexOf()：返回最后一次出现的下标</div><div><br/></div><div>forEach()：循环</div><div><br/></div><div>map():映射</div><div><br/></div><div>filter():过滤</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">048、ES5中字符串新增的方法有哪些？</span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>charAt()  获取指定位置上的字符</div><div><br/></div><div>indexOf() 获取字符第一次出现的位置</div><div><br/></div><div>substring() 截取字符串内容</div><div><br/></div><div>slice()  截取</div><div><br/></div><div>split()  将字符串分割成数组</div><div><br/></div><div>replace()  替换</div><div><br/></div><div>substr 返回一个从指定位置开始的指定长度的子字符串</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">049、如何将一个字符转换成ascii码？如何将一个数字转换成对应的字符</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>charCodeAt()：将字符转换成ascii码</div><div><br/></div><div>String.fromCharCode()：将数字转换成对应的字符</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">050、请列举出Math常见的API</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>        1、Math.random()=====随机数</div><div><br/></div><div>        2、Math.pow()====次方</div><div><br/></div><div>        3、Math.round()====四舍五入</div><div><br/></div><div>        4、Math.ceil() ===向上取整</div><div><br/></div><div>        5、Math.floor()===向下取整</div><div><br/></div><div>        6、Math.PI  ====π</div><div><br/></div><div>        7、Math.max()===返回最大值</div><div><br/></div><div>        8、Math.min()===返回最小值</div><div><br/></div><div>        9、Math.sqrt() ===开方</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">051、在js中如何用方法将10进制的字符转换成16进制和8进制</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>数字.toString(16)</div><div>数字.toString(8)</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">052、如何创建一个对象、增加、删除</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>第一种创建方式：var obj = new Object()</div><div><br/></div><div>第二种创建方式：var obj = {};</div><div><br/></div><div>增加属性：obj.属性名   obj.方法名</div><div><br/></div><div>删除属性：delete obj.属性名    delete  obj.方法名</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">053、js中常见的内置对象有哪些？</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>new String()  new Array()  new Date()   new RegExp()   等等</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">054、如何创建时间对象</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>new Date()</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">055、如何创建未来或者过去的时间对象</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>var d = new Date('2017-10-20 22:22:22')</div><div><br/></div><div>var d = new Date('2017/10/20 11:11:11')</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">056、如何获取时间戳</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>getTime();</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">057、常用的时间API</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>        set/getFullYear()====获取年份</div><div><br/></div><div>        set/getMonth()=====获取或者设置月份  月份是从0开始的</div><div><br/></div><div>        set/getDate() ====获取或者设置日期</div><div><br/></div><div>        set/getHours()====获取或设置时</div><div><br/></div><div>        set/getMinutes()===获取或设置分</div><div><br/></div><div>        se/getSeconds() ===获取或设置秒</div><div><br/></div><div>        getDay();====如果是星期日的话返回是0;</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">058、</span><span style="font-size: 12px;">如何</span><span style="font-size: 12px;">将日期格式转化成为字符串</span></div><div><span style="font-size: 12px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>function dateString(date,sign){</div><div>     if(sign==undefined){</div><div>          sign='/'</div><div>     }</div><div>return d.getFullYear()+sign+d.getMonth()+sign+d.getDate()+''+'周'+d.getDay()+d.getHours()+':'+d.getMinutes()+':'+d.getSeconds()</div><div>}</div></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="font-size: 12px;">059、将指定格式字符串转化为日期两种方式</span></div><div><span style="font-size: 12px;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>1、var d = new Date('2018-11-11')</div><div><br/></div><div>2、var oTime = Date.parse('2019-11-11')</div><div>var d = new Date(oTime)</div></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="color: rgb(51, 51, 51);">060、url的组成部分有哪些</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><img src="1707知识点_files/Image.png" type="image/png" style="height: auto;"/></div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">061、什么是浏览器缓存？</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>浏览器缓存（Browser Caching）是为了加速浏览，浏览器在用户磁盘上对请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">062、如何打印当前浏览器的版本等信息</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>navigator.userAgent</div><div><br/></div><div>返回包含浏览器版本等信息的字符串 ，常用于判断浏览器版本及使用设备（PC或者移动端</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">063、window.onload与window.onscroll的区别</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>window.onload:当页面加载完成的时候</div><div><br/></div><div>window.onscroll:当页面滚动的时候</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">064、请简述下关于DOM的增、删、查</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>增---------createElement</div><div>var oDiv = document.createElement('div');</div><div>document.body.appendChild(oDiv);//只有追加后，页面上才会出现</div><div><br/></div><div>2、删---------removeChild</div><div>语法:fatherObj.removeChild(childrenObj)</div><div><br/></div><div>参数解释：</div><div>a、fatherObj:要删除子元素的元素对象</div><div>b、childrenObj:要被删除的子元素对象</div><div><br/></div><div>3、查---------六种</div><div>document.getElementById('');常用</div><div><br/></div><div>document.getElementsByClassName('');(ie9+)常用</div><div><br/></div><div>document.getElementsByTagName('');常用</div><div><br/></div><div>document.getElementsByName('');不常用</div><div><br/></div><div>document.querySelector(选择器)(IE8+)(IE8+)</div><div>     根据选择器返回匹配到的第一个元素</div><div><br/></div><div>document.querySelectorAll(选择器);(IE8+)常用</div><div>     根据选择器返回匹配到的所有的元素</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">065、请简述下关于Dom节点的分类</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>节点分为3种类型：</div><div><br/></div><div>1、元素节点 &lt;span&gt;&lt;/span&gt;</div><div><br/></div><div>2、文本节点 &lt;span&gt;xxx&lt;/span&gt;</div><div><br/></div><div>3、属性节点 &lt;span id ='xxx'&gt;&lt;/span&gt;</div><div><br/></div><div>可以通过nodeType这个属性查看节点的类型</div><div>nodeType == 1 元素</div><div><br/></div><div>nodeType == 2 属性</div><div><br/></div><div>nodeType == 3 文本节点</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">066、获取非行间样式</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>function getStyle(obj,attr){</div><div>     if(obj.currentStyle){</div><div>          return obj.currentStyle[attr];</div><div>     }else{</div><div>         return getComputedStyle(obj,false)[attr]; </div><div>     }</div><div>}</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">067、如何获取、设置、删除自定义属性</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div> 元素.getAttribute(属性名);</div><div><br/></div><div> 元素.setAttribute(属性名,属性值);</div><div><br/></div><div>元素.removeAttribute(属性名);</div></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">068、</span><span style="font-size: 12px;">关于IE的calss与className</span></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>FF:使用setAttribute(&quot;class&quot;, vName)语句动态设置Element的class属性在firefox中是行的通的</div><div><br/></div><div>IE:在IE中却不行。因为使用IE内核的浏览器不认识&quot;class&quot;，要改用&quot;className&quot;</div></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div>069、<span style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; background-color: rgb(255, 255, 255); display: inline !important;">innerHTML、innerText和outerHTML、outerText的区别</span></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>- innerHTML 设置或获取位于对象起始和结束标签内的 HTML</div><div><br/></div><div>- outerHTML 设置或获取对象及其内容的 HTML 形式</div><div><br/></div><div>- innerText 设置或获取位于对象起始和结束标签内的文本</div><div><br/></div><div>- outerText 设置(包括标签)或获取(不包括标签)对象的文本</div><div><br/></div><div>innerText和outerText在获取时是相同效果，但在设置时，innerText仅设置标签内的文本，而outerText设置包括标签在内的文本。</div><div><br/></div><div>不同之处:</div><div>   简单的说innerHTML和outerHTML、innerText与outerText的不同之处在于：</div><div>　　1）、innerHTML与outerHTML在设置对象的内容时包含的HTML会被解析，而innerText与outerText则不会。</div><div>　　2)、在设置时，innerHTML与innerText仅设置标签内的文本，而outerHTML与outerText设置包括标签在内的文本。</div><div>   3）、outhtml innerText(非W3C)</div></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div>070、如何进行DOM节点筛选</div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>1、可以通过nodeType</div><div>1 代表元素节点   2 代表属性节点 3 代表文本节点</div><div><br/></div><div>function getNode(ele){</div><div>     var aNode = ele.childNodes;</div><div>     var newArr = [];</div><div>     for(var i=0;i&lt;aNode.length;i++){</div><div>          if(aNode[i].nodeType == 1){</div><div>              newArr.push(aNode[i]) </div><div>          }</div><div>     }</div><div>     return newArr;</div><div>}</div></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div>071、 <span style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none; display: inline !important;">childNodes与children、</span>attributes <span style="font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none; display: inline !important;">的区别</span></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>如果想获取到子元素的element节点，最好使用children方法，childNodes方法以及firstChild方法在现代浏览器中使用，都会把元素标签中的空白节点检测出来，一般我们使用这两个方法都是为了获取到元素的元素节点，空白节点会给我们造成很多不必要的bug,而children方法则是只检测element元素节点</div><div><br/></div><div>attributes：获取当前元素节点的所有属性节点集合</div></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);">072、如何获取父级节点、上一个子级节点、下一个子级节点</span></span></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div> nextElementSibling  后一个兄弟元素  （如果没有是null）</div><div><br/></div><div> previousElementSibling  前一个兄弟元素  （如果没有就是null）</div><div><br/></div><div> parentNode 获取当前节点的父节点</div></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);">073、元素节点的创建、添加、删除、替换、克隆</span></span></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);">1、创建：document.createElement('元素名');</span></div><div><span style="color: rgb(51, 51, 51);">  </span></div><div><span style="color: rgb(51, 51, 51);">2、添加：appendChild()====&gt;插入到最后       insertBefore()====&gt;插入到最前面    </span></div><div><span style="color: rgb(51, 51, 51);">  用法：</span></div><div><span style="color: rgb(51, 51, 51);">          function append(obj,newEle){</span></div><div><span style="color: rgb(51, 51, 51);">              var achildren = obj.children;</span></div><div><span style="color: rgb(51, 51, 51);">              if(achildren.length&gt;=1){</span></div><div><span style="color: rgb(51, 51, 51);">                return  obj.insertBefore(newEle,achildren[0])</span></div><div><span style="color: rgb(51, 51, 51);">               } else{</span></div><div><span style="color: rgb(51, 51, 51);">                return   obj.appendChild(newEle)</span></div><div><span style="color: rgb(51, 51, 51);">               }</span></div><div><span style="color: rgb(51, 51, 51);">          }</span></div><div><span style="color: rgb(51, 51, 51);">3、删除：box.removeChild(node) 从元素中移除某个子元素</span></div><div><span style="color: rgb(51, 51, 51);">  用法：  先找到父级节点然后在去删除子级节点</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">4、替换：box.replaceChild(子元素，父元素)</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  用法：</span></div><div><span style="color: rgb(51, 51, 51);">      父元素.replaceChild(被替换成的元素,替换元素)</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">5、克隆：clone()</span></div><div><span style="color: rgb(51, 51, 51);">     元素.clone();</span></div><div><span style="color: rgb(51, 51, 51);">     如果里面传true的话会吧整个标签的所有节点都克隆，如果没有加true,只会克隆当前元素</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);">074、浅谈关于文档碎片的理解</span></span></span></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>1、js操作dom时发生了什么？</div><div>     </div><div>   每次对dom的操作都会触发&quot;重排&quot;，这严重影响到能耗，一般通常采取的做法是尽可能的减少dom操作来减少&quot;重排&quot;</div><div><br/></div><div>2、什么是文档碎片？</div><div>  </div><div>    document.createDocumentFragment()</div><div>    一个容器，用于暂时存放创建的dom元素</div><div>    <span style="color: rgb(227, 0, 0);">（其实这个跟咱们上课说那个先让到一个元素中，然后最后appendchild一样）</span></div><div>     </div><div>3、文档碎片有什么用？</div><div>  </div><div>   将需要添加的大量元素  先添加到文档碎片  中，再将文档碎片添加到需要插入的位置，大大减少dom操作，提高性能</div></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="background-color: rgb(255, 255, 255);">075、</span>offsetWidth、offsetHeight 、offsetLeft、offsetTop、offsetParent的区别</div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>offsetWidth、offsetHeight:获取当前元素大小，是按照盒模型获取的，而我们封装的getStyle(obj,attr)是获取的元素本身的大小，没有按照盒模型获取  ，你可以理解成怪异盒模型和标准盒模型</div><div><br/></div><div>offsetLeft、offsetTop、offsetParent</div><div><br/></div><div>offsetLefr和offsetTop是获取当前元素距离第一级拥有定位元素属性的父元素的距离</div><div><br/></div><div>offsetParent:是元素的第一级拥有定位属性的父元素</div></div><div><span style="font-size: 16px;"><span style="color: rgb(173, 0, 0);"><br/></span></span></div><div>076、关于offsetX、offsetY、clientX、clientY、pageX、pageY、screenX、screenY的区别</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>offsetX、offsetY:</div><div>     鼠标相对于事件源元素（srcElement）的X,Y坐标</div><div><br/></div><div>clientX、clientY:</div><div>     鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。</div><div><br/></div><div>pageX、pagey:</div><div>     类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性</div><div><br/></div><div>screenX、screenY:</div><div>     鼠标相对于用户显示器屏幕左上角的X,Y坐标。</div></div><div><br/></div><div><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);">077、</span></span>怎么获取元素距离文档边界的值</div><div><b><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>function offset(ele){</div><div>      var obj = {};</div><div>      obj.l = ele.offsetLeft;</div><div>      obj.t = ele.offsetTop;</div><div><br/></div><div>      while(ele.offsetParent){</div><div>         ele = ele.offsetParent;</div><div><br/></div><div>         obj.l+=ele.offsetLeft;</div><div>         obj.t+=ele.offsetTop;</div><div>       }</div><div><br/></div><div>      return obj;</div><div> }</div></div><div><b><br/></b></div><div>078、如何在<b><span style="color: rgb(0, 0, 0); font-size: 13.92px; font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none; display: inline !important;">当前视窗的可见范围看见当前元素</span></b></div><div><b><span style="font-size: 13.92px;"><span style="background-color: rgb(255, 255, 255);"><br/></span></span></b></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>scrollIntoView()</div></div><div><b><span style="font-size: 13.92px;"><span style="background-color: rgb(255, 255, 255);"><br/></span></span></b></div><div><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);">079、关于onkeydown和onkeypress的区别以及如何获取按下键盘的键盘码？</span></span></div><div><span style="font-size: 16px;"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div> onkeypress:当用户按下并放开字母或数字键的时候</div><div><br/></div><div> onkeydown:当用户按下任何键时方生的事情</div><div><br/></div><div> e.keyCode：</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 